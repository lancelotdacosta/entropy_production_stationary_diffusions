'''
Computation of weak derivative of paths in Cameron-Martin space
as time goes forward and backward for a nD OU process with degenerate noise
#following computations from 18 Jun 2021
'''

import numpy as np
from numpy.linalg import inv, det, eig
from numpy.linalg import eigvals as spec
from numpy.linalg import matrix_rank as rank
from scipy.linalg import expm
from SubRoutines.Auxiliary import num
import matplotlib.pyplot as plt

# np.random.seed(1)
std = 1  # define standard deviations of distributions we are sampling random numbers

'''
Dimension
'''

maxdim = 20  # dimension of state-space

dim = np.random.choice(np.arange(2, maxdim + 1, 1))

'''
Precision matrix
'''

Pi = np.round(np.random.normal(scale=std, size=dim ** 2).reshape([dim, dim]), 1)  # random precision matrix
# enforce symmetric
Pi = (Pi + Pi.T) / 2
# make sure Pi is positive definite
if np.any(spec(Pi) <= 0):
    Pi = Pi - 2 * np.min(spec(Pi)) * np.eye(dim)

'''
Volatility
'''
# setup arbitrary change of basis matrix
arb = np.zeros([dim, dim])
while np.abs(det(arb)) < 0.1:
    arb = np.random.normal(scale=std, size=dim ** 2).reshape([dim, dim])
    arb = np.round(arb, 1)

# setup eigenvalues of sigma
n_nonzero_eigs = np.random.choice(np.arange(1, dim, 1))  # number of non-zero eigenvalues in sigma (between 1 and dim-1)
random_eigs = np.round(np.random.normal(scale=std, size=n_nonzero_eigs), 1)
random_eigs = random_eigs + 2 * (random_eigs >= 0) - 1
deg = np.zeros([dim, dim])
deg[range(n_nonzero_eigs), range(n_nonzero_eigs)] = random_eigs

# set up volatility matrix as change of basis of the deg matrix
sigma = inv(arb) @ deg @ arb

# check whether noise is degenerate or not
print(f'rank sigma = {rank(sigma)}, dim = {dim}')
if rank(sigma) != n_nonzero_eigs:  # sanity check
    print('error')

# diffusion tensor
D = sigma @ sigma.T / 2  # diffusion tensor

'''
Solenoidal flow
'''
# solenoidal flow
Q = np.round(np.random.normal(scale=std, size=dim ** 2).reshape([dim, dim]), 1)  # arbitrary solenoidal flow
# Q = np.zeros([dim, dim])  # no solenoidal flow
# Q = np.array([0,1,0,0]).reshape([dim, dim])
Q = (Q - Q.T) / 2 #make antisymmetric

'''
Drift matrices (as time goes forward and backward)
'''
Bf = (D + Q) @ Pi  # drift as time goes forward
Bb = (D - Q) @ Pi  # drift as time goes backward

'''
Kalman rank condition
'''
# we verify whether Kalman rank condition holds


def KRC(B, D):  # test Kalman rank condition
    # KRC holds iff forall v eigenvector of B.T we have Dv != 0
    # KRC doesn't hold iff exists v eigenvector of B.T with Dv==0
    B_eig = np.linalg.eig(B.T)[1]
    tol = 10 ** (-6)
    KRC = True
    for i in range(B_eig.shape[1]):
        if np.all(np.abs(D @ B_eig[:, i]) < tol):
            KRC = False
    return KRC


KRC_f = KRC(Bf, D)  # Kalman rank condition as time goes forward
KRC_b = KRC(Bf, D)  # Kalman rank condition as time goes backward
print(f'KRC forward = {KRC_f}, KRC backward = {KRC_b}')

'''
Simulation
'''
T = np.arange(0, dim + 1, 1)
expBf = np.empty([num(T), dim, dim])
expBb = np.empty([num(T), dim, dim])
Im_f = np.empty([num(T), dim, dim])
Im_b = np.empty([num(T), dim, dim])
rank_matrix = np.empty([num(T),3]) #for each t score the dimension of the space generated by Im_f+Im_b, Im_f, Im_b

for t in T:
    expBf[t, :, :] = expm(Bf * (t-T.max()))  # exponential drift matrix as time goes forward (multiplied by time horizon)
    expBb[t, :, :] = expm(Bb * (t-T.max()))  # exponential drift matrix as time goes backward (multiplied by time horizon)
    for i in range(dim):
        e_i = np.zeros([dim])
        e_i[i] = 1  # canonical basis vector
        Im_f[t, i, :] = expBf[t] @ sigma @ e_i
        Im_b[t, i, :] = expBb[t] @ sigma @ e_i

    rank_matrix[t, 0] = rank(np.concatenate((Im_f[t],Im_b[t]),axis=0))
    rank_matrix[t, 1] = rank(Im_f[t])
    rank_matrix[t, 2] = rank(Im_b[t])
    #rank_matrix[t,0] = rank_matrix[t].max() #take the maximum to avoid numerical errors of rank

'''
Plot
'''
plt.figure(0)
plt.clf()
plt.suptitle('Dimensionality of weak derivatives of Cameron-Martin space over time')
plt.title(f'dim = {dim}')
plt.plot(T, rank_matrix[:, 0], alpha=0.5, c='black', label='Both')
plt.plot(T, rank_matrix[:, 1], alpha=0.5, c='royalblue', label='Forward time')
plt.plot(T, rank_matrix[:, 2], alpha=0.5, c='darkorange', label='Backward time')
plt.legend(framealpha=0.5)


'''
Condition
'''
if np.all(rank_matrix[:, 0]==rank_matrix[:, 1]) and np.all(rank_matrix[:, 0]==rank_matrix[:, 2]):
    raise TypeError('helloworld')